Aqui est√° um comando pronto para voc√™ colar no console do Replit (supondo que seu projeto seja TypeScript/Node com a estrutura que me mostrou):

mkdir -p src/utils src/middleware && \
cat << 'EOF' > src/utils/ErrorHandler.ts
export class AppError extends Error {
  statusCode: number;
  userMessage: string;

  constructor(statusCode: number, userMessage: string, internalMessage?: string) {
    super(internalMessage || userMessage);
    this.statusCode = statusCode;
    this.userMessage = userMessage;
    Error.captureStackTrace(this, this.constructor);
  }
}

export const errorMessages = {
  GENERIC: "Ocorreu um erro inesperado. Tente novamente mais tarde.",
  INVALID_INPUT: "Os dados fornecidos s√£o inv√°lidos.",
  NOT_FOUND: "O recurso solicitado n√£o foi encontrado.",
  UNAUTHORIZED: "Voc√™ n√£o tem permiss√£o para acessar este recurso.",
  // üëâ adicione ou edite mensagens aqui facilmente
};
EOF

cat << 'EOF' > src/middleware/errorMiddleware.ts
import { Request, Response, NextFunction } from "express";
import { AppError, errorMessages } from "../utils/ErrorHandler";

export function errorMiddleware(err: any, req: Request, res: Response, next: NextFunction) {
  if (err instanceof AppError) {
    return res.status(err.statusCode).json({ error: err.userMessage });
  }

  console.error("Erro n√£o tratado:", err);
  return res.status(500).json({ error: errorMessages.GENERIC });
}
EOF

O que esse comando faz:

Cria src/utils/ErrorHandler.ts com:

Uma classe AppError (padroniza status + mensagem amig√°vel ao usu√°rio).

Um objeto errorMessages centralizado para manter as mensagens (f√°cil de alterar).

Cria src/middleware/errorMiddleware.ts:

Middleware Express para interceptar erros.

Responde sempre com mensagens amig√°veis e status corretos.

Loga os erros t√©cnicos para an√°lise, mas sem poluir a experi√™ncia do usu√°rio.

üîß Como usar no seu c√≥digo
Nos controladores/servi√ßos, ao inv√©s de lan√ßar throw new Error("msg qualquer"), use:

import { AppError, errorMessages } from "../utils/ErrorHandler";

if (!inputValido) {
  throw new AppError(400, errorMessages.INVALID_INPUT, "Valida√ß√£o falhou no campo X");
}


E no server.ts / app.ts, logo ap√≥s os app.use(routes):

import { errorMiddleware } from "./middleware/errorMiddleware";
app.use(errorMiddleware);