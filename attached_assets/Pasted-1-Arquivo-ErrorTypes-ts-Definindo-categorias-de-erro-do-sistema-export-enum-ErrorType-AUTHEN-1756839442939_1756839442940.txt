1. Arquivo ErrorTypes.ts

Definindo categorias de erro do sistema:

export enum ErrorType {
  AUTHENTICATION = "AUTHENTICATION_ERROR",
  AUTHORIZATION = "AUTHORIZATION_ERROR",
  VALIDATION = "VALIDATION_ERROR",
  RATE_LIMIT = "RATE_LIMIT_ERROR",
  SERVICE_UNAVAILABLE = "SERVICE_UNAVAILABLE_ERROR",
  UNKNOWN = "UNKNOWN_ERROR"
}

2. Arquivo ErrorMessages.ts

Centraliza mensagens amig√°veis (f√°cil de trocar):

import { ErrorType } from "./ErrorTypes";

export const ErrorMessages: Record<ErrorType, string> = {
  [ErrorType.AUTHENTICATION]: "Problema de autentica√ß√£o. Verifique suas credenciais.",
  [ErrorType.AUTHORIZATION]: "Voc√™ n√£o tem permiss√£o para realizar esta a√ß√£o.",
  [ErrorType.VALIDATION]: "Os dados enviados s√£o inv√°lidos. Verifique e tente novamente.",
  [ErrorType.RATE_LIMIT]: "Voc√™ atingiu o limite de uso. Tente novamente em alguns minutos.",
  [ErrorType.SERVICE_UNAVAILABLE]: "O servi√ßo est√° temporariamente indispon√≠vel. Tente novamente mais tarde.",
  [ErrorType.UNKNOWN]: "Ocorreu um erro inesperado. Nossa equipe j√° foi notificada."
};

3. Arquivo AppError.ts

Classe base para transportar os erros de forma padronizada:

import { ErrorType } from "./ErrorTypes";

export class AppError extends Error {
  public type: ErrorType;
  public originalError?: any;

  constructor(type: ErrorType, message?: string, originalError?: any) {
    super(message || type);
    this.type = type;
    this.originalError = originalError;
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

4. Arquivo ErrorMapper.ts

Tradu√ß√£o de erros t√©cnicos ‚Üí AppError:

import { AppError } from "./AppError";
import { ErrorType } from "./ErrorTypes";

export class ErrorMapper {
  static map(error: any): AppError {
    // Exemplos de mapeamento de c√≥digos externos
    if (error.response?.status === 401) {
      return new AppError(ErrorType.AUTHENTICATION, undefined, error);
    }
    if (error.response?.status === 403) {
      return new AppError(ErrorType.AUTHORIZATION, undefined, error);
    }
    if (error.response?.status === 400) {
      return new AppError(ErrorType.VALIDATION, undefined, error);
    }
    if (error.response?.status === 429 || error.code === "insufficient_quota") {
      return new AppError(ErrorType.RATE_LIMIT, undefined, error);
    }
    if (error.message?.includes("OpenRouter")) {
      return new AppError(ErrorType.SERVICE_UNAVAILABLE, undefined, error);
    }

    // Fallback
    return new AppError(ErrorType.UNKNOWN, undefined, error);
  }
}

5. Uso nos servi√ßos (RAGService, PineconeService, etc.)

Exemplo no RAGService:

import { ErrorMapper } from "../errors/ErrorMapper";
import { ErrorMessages } from "../errors/ErrorMessages";

async generateContextualResponse(userId: string, query: string, category?: string) {
  try {
    // fluxo normal
  } catch (err: any) {
    const appError = ErrorMapper.map(err);
    console.error("Erro em generateContextualResponse:", appError);

    return {
      response: ErrorMessages[appError.type],
      contextUsed: [],
      hasContext: false,
    };
  }
}


Exemplo no PineconeService:

import { ErrorMapper } from "../errors/ErrorMapper";

async upsert(namespace: string, vectors: any[]) {
  try {
    // fluxo normal
  } catch (err: any) {
    throw ErrorMapper.map(err); // sempre lan√ßa AppError
  }
}

üìå Benef√≠cios

F√°cil manuten√ß√£o ‚Üí todas as mensagens de erro est√£o no ErrorMessages.ts.

Clareza para o usu√°rio ‚Üí nunca recebe exce√ß√µes cruas.

Coer√™ncia no sistema ‚Üí sempre AppError no backend, sempre mensagem amig√°vel no frontend.

Escalabilidade ‚Üí se amanh√£ precisar suportar outro servi√ßo (ex.: AWS, Azure, GCP), s√≥ adiciona o mapeamento no ErrorMapper.